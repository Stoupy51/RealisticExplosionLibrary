
## Python function that aims to generate .mcfunction files that will handle which falling block will be summoned
## Items and Blocks are retrieved manually from: https://github.com/PixiGeko/Minecraft-generated-data/blob/master/1.20/releases/1.20.1/custom-generated/registries/item.txt

# Imports
import os

# Stop if the execution is not in the same folder as the script
if os.getcwd() != os.path.dirname(os.path.realpath(__file__)):
	print("Please execute this script in the same folder as the script")
	exit()

# Constants
GENERATED_SUMMONS_FOLDER = "generated_summons"


# Return a list of items that are also blocks
def getListFromItemsAndBlock() -> list:
	
	# Open the file "item.txt" and "block.txt" and read the content
	with open("item.txt", "r") as file:
		items = file.read().splitlines()
	with open("block.txt", "r") as file:
		blocks = file.read().splitlines()
	
	# For each item, add it to the final list if it's in the block list
	final_list = []
	for item in items:
		if item in blocks:
			final_list.append(item)
	
	# Return the final list
	return final_list


# Generate the .mcfunction files that will handle which falling block will be summoned
def generateSummonsFiles() -> None:
	
	# Get the list of items that are also blocks
	items = getListFromItemsAndBlock()
	
	# Create the folder if it doesn't exist
	if not os.path.exists(GENERATED_SUMMONS_FOLDER):
		os.makedirs(GENERATED_SUMMONS_FOLDER)

	# Delete the content of the folder (ending with .mcfunction)
	for file in os.listdir(GENERATED_SUMMONS_FOLDER):
		if file.endswith(".mcfunction"):
			os.remove(f"{GENERATED_SUMMONS_FOLDER}/{file}")

	# For each item, create a file in the "generated_summons" folder
	item_name_length_dict = {}
	for item in items:
		
		# Count the number of letters in the item name
		item_name_length = len(item)
		
		# If the item name length is not already in the list, add it
		if item_name_length not in item_name_length_dict:
			item_name_length_dict[item_name_length] = 0
		
		# Increment the number of items with the same name length
		item_name_length_dict[item_name_length] += 1

		# Open the file where the command will be written
		with open(f"{GENERATED_SUMMONS_FOLDER}/{item_name_length}.mcfunction", "a") as file:
			
			# Write the command in the file
			file.write(f"execute if data storage realistic_explosion:main {{id:\"{item}\"}} run summon falling_block ~ ~ ~ {{Tags:[\"realistic_explosion.new\"],DropItem:0b,BlockState:{{Name:\"{item}\"}}}}\n")

	# Sort the list of item name length
	length_list = item_name_length_dict.keys()
	length_list = sorted(length_list)

	# Open the file where the command will be written
	with open(f"{GENERATED_SUMMONS_FOLDER}/all.mcfunction", "w") as file:

		file.write(f"""

#> realistic_explosion:{GENERATED_SUMMONS_FOLDER}/all
#
# @within			???
# @executed			as & at the item entity from the explosion
#
# @description		Calculate the length of the item name and execute the corresponding function
#
# @warning			This file is auto-generated by the generator.py script, do not edit it manually!
#

# Get the length of the item name
execute store result score #length realistic_explosion.data run data get entity @s Item.id

# Copy the item id to the storage
data modify storage realistic_explosion:main id set from entity @s Item.id

# Execute the function that will summon the falling block
""")

		# For each item name length, execute the corresponding function
		for item_name_length in length_list:
			file.write(f"execute if score #length realistic_explosion.data matches {item_name_length} run function realistic_explosion:{GENERATED_SUMMONS_FOLDER}/{item_name_length}\n")
		
		# Write the end of the file
		file.write("\n")
	
	# Print done
	print("Generated summons files successfully")







# Main function
if __name__ == "__main__":
	print("\nRunning the generator.py script...\n")

	generateSummonsFiles()

	print("\nEverything is done!\n")

